<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sensor Demo Pro</title>
    <link rel="icon" href="favicon.ico">
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#9EF2B3">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="default">
    <meta name="apple-mobile-web-app-title" content="Sensor Demo Pro">
    <link rel="apple-touch-icon" href="./icons/iosicon-512x512.png">

    <script type="module" src="https://unpkg.com/@material/web/all.js?module"></script>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200" />
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@400;500;700&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

    <link href="style.css" rel="stylesheet">
</head>

<body data-theme="light">
    <div class="app-bar">
        <h1>Sensor Demo Pro</h1>
        <div class="theme-switch-container">
            <md-icon>light_mode</md-icon>
            <md-switch id="themeSwitch"></md-switch>
            <md-icon>dark_mode</md-icon>
        </div>
    </div>

    <div class="main-content">
        <!-- Page for Recording -->
        <div id="recordPage" class="page active-page">
            <div class="app-container">
                <!-- Recording Controls -->
                <div class="recording-controls-bar">
                    <div class="recording-status-area">
                        <p class="status-text" id="recordingStatus">待機中...</p>
                    </div>
                    <div class="recording-buttons-area">
                        <md-icon-button id="sensorPermissionIconButton" aria-label="センサーアクセス許可">
                            <md-icon>lock</md-icon>
                        </md-icon-button>
                        <md-icon-button id="startRecordingIconButton" aria-label="記録開始" disabled>
                            <md-icon>play_arrow</md-icon>
                        </md-icon-button>
                        <md-icon-button id="stopRecordingIconButton" aria-label="記録停止" disabled>
                            <md-icon>stop</md-icon>
                        </md-icon-button>
                        <md-icon-button id="downloadCSVIconButton" aria-label="CSVダウンロード" disabled>
                            <md-icon>download</md-icon>
                        </md-icon-button>
                    </div>
                </div>

                <!-- Device Orientation Card -->
                <md-card>
                    <div class="card-header">
                        <md-icon>screen_rotation</md-icon>
                        <h2>デバイスの向き</h2>
                    </div>
                    <div class="card-content">
                        <div class="cube-container">
                            <div class="cube" id="orientationCube">
                                <div class="cube__face cube__face--front">前</div>
                                <div class="cube__face cube__face--back">後</div>
                                <div class="cube__face cube__face--right">右</div>
                                <div class="cube__face cube__face--left">左</div>
                                <div class="cube__face cube__face--top">上</div>
                                <div class="cube__face cube__face--bottom">下</div>
                            </div>
                        </div>
                        <p class="sensor-value"><strong>Alpha (Z軸):</strong> <span id="orient-alpha">-</span> °</p>
                        <p class="sensor-value"><strong>Beta (X軸):</strong> <span id="orient-beta">-</span> °</p>
                        <p class="sensor-value"><strong>Gamma (Y軸):</strong> <span id="orient-gamma">-</span> °</p>
                        <p class="status-text" id="orient-status">待機中...</p>
                    </div>
                </md-card>

                <!-- Accelerometer Card -->
                <md-card>
                    <div class="card-header">
                        <md-icon>vibration</md-icon>
                        <h2>加速度 (重力含む)</h2>
                    </div>
                    <div class="card-content">
                        <div class="bars-container">
                            <div class="bar" id="accel-bar-x"><span class="bar-label">X</span></div>
                            <div class="bar" id="accel-bar-y"><span class="bar-label">Y</span></div>
                            <div class="bar" id="accel-bar-z"><span class="bar-label">Z</span></div>
                        </div>
                        <p class="sensor-value"><strong>X:</strong> <span id="accel-x">-</span> m/s²</p>
                        <p class="sensor-value"><strong>Y:</strong> <span id="accel-y">-</span> m/s²</p>
                        <p class="sensor-value"><strong>Z:</strong> <span id="accel-z">-</span> m/s²</p>
                        <p class="status-text" id="accel-status">待機中...</p>
                    </div>
                </md-card>

                <!-- Gyroscope Card -->
                <md-card>
                    <div class="card-header">
                        <md-icon>explore</md-icon>
                        <h2>ジャイロスコープ (回転速度)</h2>
                    </div>
                    <div class="card-content">
                        <p class="sensor-value"><strong>Alpha (Z軸):</strong> <span id="gyro-alpha">-</span> °/s</p>
                        <p class="sensor-value"><strong>Beta (X軸):</strong> <span id="gyro-beta">-</span> °/s</p>
                        <p class="sensor-value"><strong>Gamma (Y軸):</strong> <span id="gyro-gamma">-</span> °/s</p>
                        <p class="status-text" id="gyro-status">待機中...</p>
                    </div>
                </md-card>

                <!-- Pedometer Card -->
                <md-card>
                    <div class="card-header">
                        <md-icon>directions_walk</md-icon>
                        <h2>歩数計 (試作版)</h2>
                    </div>
                    <div class="card-content">
                        <p class="sensor-value" style="font-size: 1.1em;"><strong>記録中の歩数:</strong> <span id="pedometer-steps">0</span> 歩</p>
                        <p class="status-text" id="pedometer-status">待機中...</p>
                        <p style="font-size: 0.7em; color: var(--md-sys-color-on-surface-variant);">※ 加速度センサーに基づく簡易的な推定です。</p>
                    </div>
                </md-card>

                <!-- Geolocation & Weather Card -->
                <md-card>
                    <div class="card-header">
                        <md-icon>location_on</md-icon>
                        <h2>位置情報 & 天気</h2>
                    </div>
                    <div class="card-content">
                        <p class="sensor-value"><strong>緯度:</strong> <span id="geo-lat">-</span></p>
                        <p class="sensor-value"><strong>経度:</strong> <span id="geo-lon">-</span></p>
                        <p class="sensor-value"><strong>精度:</strong> <span id="geo-acc">-</span> m</p>
                        <p class="sensor-value"><strong>高度:</strong> <span id="geo-alt">-</span> m</p>
                        <p class="sensor-value"><strong>速度:</strong> <span id="geo-speed">-</span> m/s</p>
                        <p class="sensor-value"><strong>方角:</strong> <span id="geo-head">-</span> °</p>
                        <p class="sensor-value"><strong>場所:</strong> <span id="geo-address">-</span></p>
                        <p class="status-text" id="geo-address-status"></p>
                        <p class="status-text" id="geo-status">待機中...</p>
                        <hr style="margin: 12px 0 8px; border: 0; border-top: 1px solid var(--md-sys-color-outline-variant);">
                        <p class="sensor-value"><strong>現在地の気温:</strong> <span id="weather-temp">-</span> °C</p>
                        <p class="status-text" id="weather-status">GPS位置情報取得後に更新</p>
                    </div>
                </md-card>

                <!-- Light Sensor Card -->
                <md-card>
                    <div class="card-header">
                        <md-icon>lightbulb</md-icon>
                        <h2>光センサー</h2>
                    </div>
                    <div class="card-content">
                        <div class="light-viz">
                            <md-icon id="light-icon-sun" style="display:none;">wb_sunny</md-icon>
                            <md-icon id="light-icon-moon" style="display:none;">nightlight_round</md-icon>
                        </div>
                        <p class="sensor-value"><strong>明るさ:</strong> <span id="light-value">-</span> lux</p>
                        <p class="status-text" id="light-status">待機中...</p>
                    </div>
                </md-card>

                <!-- Microphone Card -->
                <md-card>
                    <div class="card-header">
                        <md-icon>mic</md-icon>
                        <h2>マイク (音量)</h2>
                    </div>
                    <div class="card-content">
                        <p class="sensor-value"><strong>音量 (dBFS):</strong> <span id="mic-dbfs">-</span> dBFS</p>
                        <div class="mic-level-bar-container">
                            <div class="mic-level-bar" id="micLevelBar"></div>
                        </div>
                        <p class="status-text" id="mic-status">待機中...</p>
                    </div>
                </md-card>

                <!-- Camera Card -->
                <md-card>
                    <div class="card-header">
                        <md-icon>photo_camera</md-icon>
                        <h2>写真撮影</h2>
                    </div>
                    <div class="card-content">
                        <video id="cameraPreview" playsinline autoplay muted style="display:none; width: 100%; max-width:300px; border-radius: 8px; margin-bottom:10px;"></video>
                        <canvas id="photoCanvas" style="display:none;"></canvas>
                        <md-filled-button id="takePictureButton" disabled>
                            <md-icon slot="icon">camera_alt</md-icon>
                            写真を撮る
                        </md-filled-button>
                        <p class="status-text" id="camera-status">カメラ準備中...</p>
                        <div id="lastPhotoPreviewContainer" style="margin-top: 10px;"></div>
                    </div>
                </md-card>

                <p style="font-size: 0.8em; text-align: center; margin-top: 20px; color: var(--md-sys-color-on-surface-variant);">
                    注意: センサーの利用にはブラウザからの許可が必要な場合があります。
                </p>
            </div>
        </div>

        <!-- Page for Recording History -->
        <div id="historyPage" class="page">
            <div class="app-container">
                <h2>記録履歴</h2>
                <p id="noHistoryText" style="text-align:center; color: var(--md-sys-color-on-surface-variant);">記録されたセッションはありません。</p>
                <div id="historyListContainer">
                    <!-- History items will be injected here -->
                </div>
                <div id="historyDetailView" style="display:none; margin-top:20px;">
                    <h3 id="historyDetailTitle"></h3>
                    <md-outlined-button id="backToHistoryListButton" style="margin-bottom:10px;">
                        <md-icon slot="icon">arrow_back</md-icon>
                        一覧へ戻る
                    </md-outlined-button>
                    <h4>センサーデータグラフ</h4>
                    <canvas id="historyChart" width="400" height="300"></canvas>
                    <h4>撮影された写真</h4>
                    <div id="historyPhotosContainer" style="display:flex; flex-wrap:wrap; gap:10px; margin-top:10px;"></div>
                    <md-filled-button id="exportHistoryCSVButton" style="margin-top:20px;">
                        <md-icon slot="icon">download</md-icon>
                        この記録をCSVでエクスポート
                    </md-filled-button>
                </div>
            </div>
        </div>
    </div>

    <!-- Bottom Navigation Bar -->
    <md-navigation-bar>
        <md-navigation-tab id="navRecordTab" label="記録">
            <md-icon slot="activeIcon">sensors</md-icon>
            <md-icon slot="inactiveIcon">sensors</md-icon>
        </md-navigation-tab>
        <md-navigation-tab id="navHistoryTab" label="記録履歴">
            <md-icon slot="activeIcon">history</md-icon>
            <md-icon slot="inactiveIcon">history</md-icon>
        </md-navigation-tab>
    </md-navigation-bar>

    <md-dialog id="deleteConfirmDialog">
        <div slot="headline">記録の削除</div>
        <form slot="content" id="deleteConfirmForm" method="dialog">
            <p>この記録セッションを本当に削除しますか？この操作は元に戻せません。</p>
            <p id="deleteDialogSessionInfo" style="font-size: 0.9em; color: var(--md-sys-color-on-surface-variant);"></p>
        </form>
        <div slot="actions">
            <md-text-button form="deleteConfirmForm" value="cancel">キャンセル</md-text-button>
            <md-filled-tonal-button id="confirmDeleteButton" value="delete">削除</md-filled-tonal-button>
        </div>
    </md-dialog>
    

    <script type="module">
        // MWC Components, DOM Elements, etc.
        const body = document.body;
        const themeSwitch = document.getElementById('themeSwitch');

        // Page containers
        const recordPage = document.getElementById('recordPage');
        const historyPage = document.getElementById('historyPage');
        const navRecordTab = document.getElementById('navRecordTab');
        const navHistoryTab = document.getElementById('navHistoryTab');

        // Recording Elements
        const sensorPermissionIconButton = document.getElementById('sensorPermissionIconButton');
        const startRecordingIconButton = document.getElementById('startRecordingIconButton');
        const stopRecordingIconButton = document.getElementById('stopRecordingIconButton');
        const downloadCSVIconButton = document.getElementById('downloadCSVIconButton');
        const recordingStatusEl = document.getElementById('recordingStatus');

        // Sensor UI Elements (existing)
        const orientationCube = document.getElementById('orientationCube');
        const orientAlphaEl = document.getElementById('orient-alpha');
        const orientBetaEl = document.getElementById('orient-beta');
        const orientGammaEl = document.getElementById('orient-gamma');
        const orientStatusEl = document.getElementById('orient-status');
        const accelXEl = document.getElementById('accel-x');
        const accelYEl = document.getElementById('accel-y');
        const accelZEl = document.getElementById('accel-z');
        const accelStatusEl = document.getElementById('accel-status');
        const accelBarX = document.getElementById('accel-bar-x');
        const accelBarY = document.getElementById('accel-bar-y');
        const accelBarZ = document.getElementById('accel-bar-z');
        const BAR_MAX_ACCEL = 20;
        const gyroAlphaEl = document.getElementById('gyro-alpha');
        const gyroBetaEl = document.getElementById('gyro-beta');
        const gyroGammaEl = document.getElementById('gyro-gamma');
        const gyroStatusEl = document.getElementById('gyro-status');
        const lightValueEl = document.getElementById('light-value');
        const lightStatusEl = document.getElementById('light-status');
        const lightIconSun = document.getElementById('light-icon-sun');
        const lightIconMoon = document.getElementById('light-icon-moon');
        const micDbfsEl = document.getElementById('mic-dbfs');
        const micStatusEl = document.getElementById('mic-status');
        const micLevelBar = document.getElementById('micLevelBar');
        const cameraPreview = document.getElementById('cameraPreview');
        const photoCanvas = document.getElementById('photoCanvas');
        const takePictureButton = document.getElementById('takePictureButton');
        const cameraStatusEl = document.getElementById('camera-status');
        const lastPhotoPreviewContainer = document.getElementById('lastPhotoPreviewContainer');

        // Geolocation & Weather UI Elements
        const geoLatEl = document.getElementById('geo-lat');
        const geoLonEl = document.getElementById('geo-lon');
        const geoAccEl = document.getElementById('geo-acc');
        const geoAltEl = document.getElementById('geo-alt');
        const geoSpeedEl = document.getElementById('geo-speed');
        const geoHeadEl = document.getElementById('geo-head');
        const geoAddressEl = document.getElementById('geo-address'); // New
        const geoAddressStatusEl = document.getElementById('geo-address-status'); // New
        const geoStatusEl = document.getElementById('geo-status');
        const weatherTempEl = document.getElementById('weather-temp');
        const weatherStatusEl = document.getElementById('weather-status');

        // Pedometer UI Elements
        const pedometerStepsEl = document.getElementById('pedometer-steps');
        const pedometerStatusEl = document.getElementById('pedometer-status');


        // History Page Elements
        const noHistoryText = document.getElementById('noHistoryText');
        const historyListContainer = document.getElementById('historyListContainer');
        const historyDetailView = document.getElementById('historyDetailView');
        const historyDetailTitle = document.getElementById('historyDetailTitle');
        const backToHistoryListButton = document.getElementById('backToHistoryListButton');
        const historyChartCanvas = document.getElementById('historyChart');
        const historyPhotosContainer = document.getElementById('historyPhotosContainer');
        const exportHistoryCSVButton = document.getElementById('exportHistoryCSVButton');
        let historyChartInstance = null;

        // Delete Dialog
        const deleteConfirmDialog = document.getElementById('deleteConfirmDialog');
        const confirmDeleteButton = document.getElementById('confirmDeleteButton');
        const deleteDialogSessionInfo = document.getElementById('deleteDialogSessionInfo');
        let sessionIdToDelete = null;

        // --- Global State ---
        let isRecording = false;
        let currentRecordingData = [];
        let currentRecordingPhotos = [];
        let recordingIntervalId = null;
        const RECORDING_INTERVAL_MS = 100;

        let currentSensorValues = {
            timestamp: null,
            accelX: null, accelY: null, accelZ: null,
            orientAlpha: null, orientBeta: null, orientGamma: null,
            gyroAlpha: null, gyroBeta: null, gyroGamma: null,
            illuminance: null,
            decibels: null,
            latitude: null, longitude: null, gpsAccuracy: null, altitude: null, speed: null, heading: null,
            address: null, // For reverse geocoded address
            temperature_celsius: null,
            steps_interval: 0,
            photoTakenId: null
        };

        let allRecordedSessions = []; 

        // Audio Variables
        let audioContext = null;
        let analyserNode = null;
        let microphoneStream = null;
        let micPermissionGranted = false;

        // Camera Variables
        let cameraStream = null;
        let cameraPermissionGranted = false;

        // Geolocation Variables
        let geolocationPermissionGranted = false;
        let geoWatchId = null;
        let lastWeatherFetchTime = 0;
        const WEATHER_FETCH_INTERVAL_MS = 10 * 60 * 1000;
        let lastFetchedAddressCoords = { lat: null, lon: null }; // For reverse geocoding frequency
        let lastReverseGeocodeFetchTime = 0;
        const REVERSE_GEOCODE_INTERVAL_MS = 15000; // Min 15s between reverse geocode calls
        const REVERSE_GEOCODE_MIN_COORD_CHANGE = 0.0005; // Approx 50m latitude/longitude change

        // Pedometer Variables
        let currentSessionTotalSteps = 0;
        let pedometer_last_accel_mag = 0;
        let pedometer_trending_up = false;
        let pedometer_last_step_time = 0;
        const PEDOMETER_MAGNITUDE_HIGH_THRESHOLD = 11.5; 
        const PEDOMETER_MIN_TIME_BETWEEN_STEPS_MS = 280; 


        // --- Theme Switch Logic (same as before) ---
        function applyTheme(theme) {
            body.dataset.theme = theme;
            localStorage.setItem('theme', theme);
            if (themeSwitch) {
                themeSwitch.selected = (theme === 'dark');
                themeSwitch.ariaLabel = theme === 'dark' ? 'ライトテーマに切り替え' : 'ダークテーマに切り替え';
            }
        }
        const prefersDarkScheme = window.matchMedia('(prefers-color-scheme: dark)');
        const savedTheme = localStorage.getItem('theme');
        const currentTheme = savedTheme || (prefersDarkScheme.matches ? 'dark' : 'light');
        applyTheme(currentTheme);
        prefersDarkScheme.addEventListener('change', (e) => {
            if (!localStorage.getItem('theme')) {
                applyTheme(e.matches ? 'dark' : 'light');
            }
        });
        if (themeSwitch) {
            themeSwitch.addEventListener('change', () => {
                applyTheme(themeSwitch.selected ? 'dark' : 'light');
            });
        }

        // --- Page Navigation Logic (same as before) ---
        function showPage(pageId) {
            document.querySelectorAll('.page').forEach(p => p.classList.remove('active-page'));
            document.getElementById(pageId).classList.add('active-page');
            if (pageId === 'historyPage') {
                loadAndDisplayHistory();
            }
        }
        navRecordTab.addEventListener('click', () => showPage('recordPage'));
        navHistoryTab.addEventListener('click', () => showPage('historyPage'));
        navRecordTab.active = true;


        // --- Sensor Permission and Initialization (same as before, with updates) ---
        let motionPermissionGranted = false;
        let orientationPermissionGranted = false;
        let sensorsInitialized = false;
        let anySensorSupported = false;

        const needsExplicitPermission = (window.DeviceMotionEvent && typeof DeviceMotionEvent.requestPermission === 'function') ||
                                    (window.DeviceOrientationEvent && typeof DeviceOrientationEvent.requestPermission === 'function') ||
                                    (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) || 
                                    (navigator.geolocation); 

        function updateRecordingButtonState() { /* ... (same as before) ... */ 
            if (!startRecordingIconButton) return;
            const permissionIconEl = sensorPermissionIconButton ? sensorPermissionIconButton.querySelector('md-icon') : null;
            
            const allCorePermissionsGranted = motionPermissionGranted && orientationPermissionGranted && micPermissionGranted && cameraPermissionGranted && geolocationPermissionGranted;
            const canRunWithoutExplicitRequestAPI = !needsExplicitPermission && anySensorSupported;

            if (needsExplicitPermission && !(motionPermissionGranted && orientationPermissionGranted && micPermissionGranted && cameraPermissionGranted && geolocationPermissionGranted) && sensorPermissionIconButton) {
                sensorPermissionIconButton.style.display = 'inline-flex';
                sensorPermissionIconButton.disabled = false;
                if (permissionIconEl) permissionIconEl.textContent = 'lock';
            } else if (sensorPermissionIconButton) {
                sensorPermissionIconButton.style.display = 'inline-flex';
                sensorPermissionIconButton.disabled = true;
                if (permissionIconEl) permissionIconEl.textContent = (allCorePermissionsGranted || anySensorSupported || canRunWithoutExplicitRequestAPI) ? 'lock_open' : 'lock';
            }
            
            const essentialSensorsReady = sensorsInitialized && 
                                          (anySensorSupported || motionPermissionGranted || orientationPermissionGranted || micPermissionGranted || geolocationPermissionGranted);

            startRecordingIconButton.disabled = !essentialSensorsReady || isRecording;
            stopRecordingIconButton.disabled = !essentialSensorsReady || !isRecording;
            downloadCSVIconButton.disabled = !essentialSensorsReady || isRecording || currentRecordingData.length === 0;
            takePictureButton.disabled = !cameraPermissionGranted || !cameraStream; 

            if (isRecording) {
                recordingStatusEl.textContent = `記録中... (${currentRecordingData.length}件)`;
            } else if (currentRecordingData.length > 0) {
                recordingStatusEl.textContent = `記録停止。${currentRecordingData.length}件。CSVダウンロード可。`;
            } else if (essentialSensorsReady) {
                recordingStatusEl.textContent = "センサー監視中。記録を開始できます。";
            } else if (sensorsInitialized && !anySensorSupported && !allCorePermissionsGranted) {
                recordingStatusEl.textContent = "利用可能なセンサーがありません。";
            } else if (needsExplicitPermission && !allCorePermissionsGranted) {
                let missingPerms = [];
                if (!motionPermissionGranted && (window.DeviceMotionEvent && typeof DeviceMotionEvent.requestPermission === 'function') ) missingPerms.push("動作");
                if (!orientationPermissionGranted && (window.DeviceOrientationEvent && typeof DeviceOrientationEvent.requestPermission === 'function') ) missingPerms.push("向き");
                if (!micPermissionGranted && (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) ) missingPerms.push("マイク");
                if (!cameraPermissionGranted && (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) ) missingPerms.push("カメラ");
                if (!geolocationPermissionGranted && navigator.geolocation) missingPerms.push("位置情報");
                if (missingPerms.length > 0) {
                    recordingStatusEl.textContent = `左のアイコンから${missingPerms.join('/')}アクセスを許可してください。`;
                } else {
                     recordingStatusEl.textContent = "センサー準備中または利用不可。"; // Fallback if no specific permission is obviously missing from the list
                }
            } else {
                recordingStatusEl.textContent = "センサー準備中または利用不可。";
            }
        }

        async function initializeSensors() { /* ... (same as before) ... */ 
            if (sensorsInitialized) return;

            if (motionPermissionGranted || (window.DeviceMotionEvent && typeof DeviceMotionEvent.requestPermission !== 'function')) {
                window.addEventListener('devicemotion', handleMotionEvent, { passive: true });
                accelStatusEl.textContent = "監視中..."; gyroStatusEl.textContent = "監視中...";
                pedometerStatusEl.textContent = "監視中...";
                if(!motionPermissionGranted) motionPermissionGranted = true;
            } else if (!window.DeviceMotionEvent) {
                accelStatusEl.textContent = '加速度センサー非対応'; accelStatusEl.classList.add('not-supported');
                gyroStatusEl.textContent = 'ジャイロスコープ非対応'; gyroStatusEl.classList.add('not-supported');
                pedometerStatusEl.textContent = '加速度センサー非対応'; pedometerStatusEl.classList.add('not-supported');
            }

            if (orientationPermissionGranted || (window.DeviceOrientationEvent && typeof DeviceOrientationEvent.requestPermission !== 'function')) {
                window.addEventListener('deviceorientation', handleOrientationEvent, { passive: true });
                orientStatusEl.textContent = "監視中...";
                if(!orientationPermissionGranted) orientationPermissionGranted = true;
            } else if(!window.DeviceOrientationEvent) {
                orientStatusEl.textContent = '向きセンサー非対応'; orientStatusEl.classList.add('not-supported');
            }

            initializeLightSensor();
            initializeMicrophone();
            initializeCamera();
            initializeGeolocation(); 

            sensorsInitialized = true;
            updateRecordingButtonState();
        }

        async function requestAllPermissions() { /* ... (same as before) ... */ 
            const promises = [];
            if (window.DeviceMotionEvent && typeof DeviceMotionEvent.requestPermission === 'function' && !motionPermissionGranted) {
                promises.push(
                    DeviceMotionEvent.requestPermission().then(state => {
                        if (state === 'granted') motionPermissionGranted = true;
                        else { accelStatusEl.textContent = '加速度アクセス拒否'; gyroStatusEl.textContent = 'ジャイロアクセス拒否'; pedometerStatusEl.textContent = '加速度アクセス拒否';}
                    }).catch(err => { console.error("Motion Err:", err); accelStatusEl.textContent = '加速度エラー'; gyroStatusEl.textContent = 'ジャイロエラー'; pedometerStatusEl.textContent = '加速度エラー';})
                );
            }
            if (window.DeviceOrientationEvent && typeof DeviceOrientationEvent.requestPermission === 'function' && !orientationPermissionGranted) {
                promises.push(
                    DeviceOrientationEvent.requestPermission().then(state => {
                        if (state === 'granted') orientationPermissionGranted = true;
                        else { orientStatusEl.textContent = '向きアクセス拒否'; }
                    }).catch(err => { console.error("Orientation Err:", err); orientStatusEl.textContent = '向きエラー';})
                );
            }

            if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
                if (!micPermissionGranted) promises.push(initializeMicrophone(true));
                if (!cameraPermissionGranted) promises.push(initializeCamera(true));
            }
            
            if (navigator.geolocation && !geolocationPermissionGranted) {
                promises.push(new Promise((resolve) => { 
                    initializeGeolocation(true).finally(resolve);
                }));
            }

            if (promises.length > 0) {
                await Promise.allSettled(promises);
            }
            initializeSensors();
        }
        
        if (needsExplicitPermission) {
            if (sensorPermissionIconButton) {
                sensorPermissionIconButton.addEventListener('click', requestAllPermissions);
            }
             accelStatusEl.textContent = "アイコンから許可"; gyroStatusEl.textContent = "アイコンから許可";
             orientStatusEl.textContent = "アイコンから許可"; micStatusEl.textContent = "アイコンから許可";
             cameraStatusEl.textContent = "アイコンから許可"; geoStatusEl.textContent = "アイコンから許可";
             pedometerStatusEl.textContent = "アイコンから許可";
             geoAddressStatusEl.textContent = "GPS許可後";
        } else { 
            if(sensorPermissionIconButton) sensorPermissionIconButton.style.display = 'none';
            motionPermissionGranted = !!window.DeviceMotionEvent;
            orientationPermissionGranted = !!window.DeviceOrientationEvent;
            initializeSensors();
        }


        // --- Sensor Event Handlers (motion, orientation, light, mic, camera same as before) ---
        function handleMotionEvent(event) { /* ... (same as before) ... */ 
            if (!motionPermissionGranted && !(window.DeviceMotionEvent && typeof DeviceMotionEvent.requestPermission !== 'function')) return;
            anySensorSupported = true;
            let currentAccelX = null, currentAccelY = null, currentAccelZ = null;

            if (event.accelerationIncludingGravity) {
                const { x, y, z } = event.accelerationIncludingGravity;
                currentSensorValues.accelX = x; currentSensorValues.accelY = y; currentSensorValues.accelZ = z;
                currentAccelX = x; currentAccelY = y; currentAccelZ = z; 
                accelXEl.textContent = x ? x.toFixed(2) : '-'; accelYEl.textContent = y ? y.toFixed(2) : '-'; accelZEl.textContent = z ? z.toFixed(2) : '-';
                requestAnimationFrame(() => {
                    accelBarX.style.height = `${Math.min(100, (Math.abs(x || 0) / BAR_MAX_ACCEL) * 100)}%`;
                    accelBarY.style.height = `${Math.min(100, (Math.abs(y || 0) / BAR_MAX_ACCEL) * 100)}%`;
                    accelBarZ.style.height = `${Math.min(100, (Math.abs(z || 0) / BAR_MAX_ACCEL) * 100)}%`;
                });
                if (accelStatusEl.textContent !== "監視中...") accelStatusEl.textContent = "監視中...";
            }
            if (event.rotationRate) {
                const { alpha, beta, gamma } = event.rotationRate;
                currentSensorValues.gyroAlpha = alpha; currentSensorValues.gyroBeta = beta; currentSensorValues.gyroGamma = gamma;
                gyroAlphaEl.textContent = alpha ? alpha.toFixed(2) : '-'; gyroBetaEl.textContent = beta ? beta.toFixed(2) : '-'; gyroGammaEl.textContent = gamma ? gamma.toFixed(2) : '-';
                if (gyroStatusEl.textContent !== "監視中...") gyroStatusEl.textContent = "監視中...";
            }

            if (currentAccelX !== null && currentAccelY !== null && currentAccelZ !== null) {
                const mag = Math.sqrt(currentAccelX**2 + currentAccelY**2 + currentAccelZ**2);
                currentSensorValues.steps_interval = 0; 

                if (isRecording) {
                    const now = Date.now();
                    if (mag > pedometer_last_accel_mag) { 
                        pedometer_trending_up = true;
                    } else if (mag < pedometer_last_accel_mag && pedometer_trending_up) { 
                        if (pedometer_last_accel_mag > PEDOMETER_MAGNITUDE_HIGH_THRESHOLD &&
                            (now - pedometer_last_step_time) > PEDOMETER_MIN_TIME_BETWEEN_STEPS_MS) {
                            currentSessionTotalSteps++;
                            currentSensorValues.steps_interval = 1;
                            pedometer_last_step_time = now;
                            if (pedometerStepsEl) pedometerStepsEl.textContent = currentSessionTotalSteps;
                        }
                        pedometer_trending_up = false;
                    }
                    pedometer_last_accel_mag = mag;
                }
                if (pedometerStatusEl.textContent !== "監視中...") pedometerStatusEl.textContent = "監視中...";
            } else if (motionPermissionGranted && pedometerStatusEl.textContent === "監視中..." && !event.accelerationIncludingGravity) {
                 pedometerStatusEl.textContent = "加速度データなし";
            }
            if (sensorsInitialized) updateRecordingButtonState();
        }
        function handleOrientationEvent(event) { /* ... (same as before) ... */ 
            if (!orientationPermissionGranted && !(window.DeviceOrientationEvent && typeof DeviceOrientationEvent.requestPermission !== 'function')) return;
            anySensorSupported = true;
            const { alpha, beta, gamma } = event;
            currentSensorValues.orientAlpha = alpha; currentSensorValues.orientBeta = beta; currentSensorValues.orientGamma = gamma;
            orientAlphaEl.textContent = alpha ? alpha.toFixed(1) : '-'; orientBetaEl.textContent = beta ? beta.toFixed(1) : '-'; orientGammaEl.textContent = gamma ? gamma.toFixed(1) : '-';
            if (beta !== null && gamma !== null && alpha !== null) {
                requestAnimationFrame(() => {
                    orientationCube.style.transform = `rotateX(${beta.toFixed(1)}deg) rotateY(${gamma.toFixed(1)}deg) rotateZ(${alpha.toFixed(1)}deg)`;
                });
            }
            if (orientStatusEl.textContent !== "監視中...") orientStatusEl.textContent = "監視中...";
            if (sensorsInitialized) updateRecordingButtonState();
        }
        function initializeLightSensor() { /* ... (same as before) ... */ 
            if (!('AmbientLightSensor' in window)) {
                lightStatusEl.textContent = '光センサー API 非対応'; lightStatusEl.classList.add('not-supported');
                currentSensorValues.illuminance = null; if (sensorsInitialized) updateRecordingButtonState(); return;
            }
            lightStatusEl.textContent = "アクセス許可待機中...";
            const startSensor = () => {
                try {
                    const sensor = new AmbientLightSensor({ frequency: 1 });
                    sensor.addEventListener('reading', () => {
                        anySensorSupported = true; 
                        const illuminance = sensor.illuminance;
                        currentSensorValues.illuminance = illuminance;
                        lightValueEl.textContent = illuminance ? illuminance.toFixed(0) : '-';
                        lightStatusEl.textContent = "監視中..."; lightStatusEl.classList.remove('error', 'not-supported');
                        if (illuminance === null || typeof illuminance === 'undefined') {}
                        else if (illuminance > 100) { lightIconSun.style.display = 'inline-block'; lightIconMoon.style.display = 'none'; }
                        else if (illuminance < 10) { lightIconSun.style.display = 'none'; lightIconMoon.style.display = 'inline-block'; }
                        else { lightIconSun.style.display = 'none'; lightIconMoon.style.display = 'none'; }
                        if (sensorsInitialized) updateRecordingButtonState();
                    });
                    sensor.addEventListener('error', event => { 
                        console.error('Light sensor error:', event.error.name, event.error.message);
                        lightStatusEl.textContent = `光センサーエラー: ${event.error.name}`; lightStatusEl.classList.add('error');
                        currentSensorValues.illuminance = null; if (sensorsInitialized) updateRecordingButtonState();
                    });
                    sensor.start();
                } catch (error) {
                    console.error('Failed to start light sensor:', error);
                    lightStatusEl.textContent = `光センサー開始失敗: ${error.name}`; lightStatusEl.classList.add('error');
                    currentSensorValues.illuminance = null; if (sensorsInitialized) updateRecordingButtonState();
                }
            };
            if (navigator.permissions && navigator.permissions.query) {
                navigator.permissions.query({ name: 'ambient-light-sensor' })
                    .then(permissionStatus => {
                        if (permissionStatus.state === 'granted') startSensor();
                        else if (permissionStatus.state === 'prompt') lightStatusEl.textContent = '光センサー: ブラウザが許可を求めています。';
                        else { lightStatusEl.textContent = '光センサーアクセス拒否'; lightStatusEl.classList.add('error'); }
                        permissionStatus.onchange = () => { if (permissionStatus.state === 'granted') startSensor(); else if (permissionStatus.state !== 'prompt') { lightStatusEl.textContent = '光センサーアクセス拒否'; lightStatusEl.classList.add('error');} if (sensorsInitialized) updateRecordingButtonState(); };
                        if (sensorsInitialized && permissionStatus.state !== 'granted') updateRecordingButtonState();
                    })
                    .catch(e => { console.warn("Ambient Light Sensor permission query failed, attempting to start directly.", e); startSensor(); });
            } else { startSensor(); }
        }
        async function initializeMicrophone(forcePermissionRequest = false) { /* ... (same as before) ... */ 
            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                micStatusEl.textContent = 'マイク API 非対応'; micStatusEl.classList.add('not-supported');
                micPermissionGranted = false; updateRecordingButtonState(); return Promise.resolve();
            }
            if (microphoneStream && !forcePermissionRequest) return Promise.resolve();

            micStatusEl.textContent = "マイクアクセス許可待機中...";
            try {
                microphoneStream = await navigator.mediaDevices.getUserMedia({ audio: true, video: false });
                micPermissionGranted = true; anySensorSupported = true;
                micStatusEl.textContent = "監視中..."; micStatusEl.classList.remove('error', 'not-supported');
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                
                if (audioContext.state === 'suspended') {
                    await audioContext.resume().catch(e => console.error("[Mic] Error resuming AudioContext on init:", e));
                }
                
                analyserNode = audioContext.createAnalyser();
                const source = audioContext.createMediaStreamSource(microphoneStream);
                source.connect(analyserNode);
                analyserNode.fftSize = 256;
                const bufferLength = analyserNode.frequencyBinCount;
                const dataArray = new Uint8Array(bufferLength);

                function getDecibels() {
                    if (!micPermissionGranted || !analyserNode || !audioContext) {
                        currentSensorValues.decibels = null; micDbfsEl.textContent = "-"; micLevelBar.style.width = `0%`; return;
                    }
                    if (audioContext.state === 'suspended') {
                        audioContext.resume().then(() => { if (audioContext.state === 'running') requestAnimationFrame(getDecibels); })
                                       .catch(e => console.error("[Mic] Error resuming AudioContext in getDecibels:", e));
                        return; 
                    }
                    
                    analyserNode.getByteFrequencyData(dataArray);
                    let sum = 0;
                    for (let i = 0; i < bufferLength; i++) sum += dataArray[i];
                    let average = sum / bufferLength;
                    let pseudoDbFs = (average / 128.0) * 60.0 - 60.0;
                    if (average < 1) pseudoDbFs = -Infinity;

                    currentSensorValues.decibels = pseudoDbFs;
                    micDbfsEl.textContent = isFinite(pseudoDbFs) ? pseudoDbFs.toFixed(1) : '-∞';
                    
                    let levelPercent = Math.min(100, Math.max(0, (average / 100) * 100));
                    micLevelBar.style.width = `${levelPercent}%`;
                    micLevelBar.style.backgroundColor = (isFinite(pseudoDbFs) && pseudoDbFs > -50) ? 'var(--md-sys-color-primary)' : 'var(--md-sys-color-secondary-container)';

                    if (audioContext.state === 'running') requestAnimationFrame(getDecibels);
                }
                if (audioContext.state === 'running') requestAnimationFrame(getDecibels);
                updateRecordingButtonState();
                return Promise.resolve();
            } catch (err) {
                console.error("[Mic] Microphone access error:", err);
                micStatusEl.textContent = `マイクエラー: ${err.name}`; micStatusEl.classList.add('error');
                micPermissionGranted = false; updateRecordingButtonState(); return Promise.reject(err);
            }
        }
        async function initializeCamera(forcePermissionRequest = false) { /* ... (same as before) ... */ 
            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                cameraStatusEl.textContent = 'カメラ API 非対応'; cameraStatusEl.classList.add('not-supported');
                cameraPermissionGranted = false; updateRecordingButtonState(); return Promise.resolve();
            }
            if (cameraStream && !forcePermissionRequest) return Promise.resolve();

            cameraStatusEl.textContent = "カメラアクセス許可待機中...";
            try {
                cameraStream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: "environment" }, audio: false });
                cameraPermissionGranted = true; anySensorSupported = true; 
                cameraStatusEl.textContent = "カメラ準備完了。撮影できます。"; cameraStatusEl.classList.remove('error', 'not-supported');
                cameraPreview.srcObject = cameraStream;
                cameraPreview.style.display = 'block';
                updateRecordingButtonState();
                return Promise.resolve();
            } catch (err) {
                console.error("Camera access error:", err);
                cameraStatusEl.textContent = `カメラエラー: ${err.name}`; cameraStatusEl.classList.add('error');
                cameraPreview.style.display = 'none';
                cameraPermissionGranted = false;
                updateRecordingButtonState();
                return Promise.reject(err);
            }
        }
        takePictureButton.addEventListener('click', () => { /* ... (same as before) ... */ 
            if (!cameraStream || !cameraPermissionGranted) {
                alert("カメラが利用できません。"); return;
            }
            const videoTracks = cameraStream.getVideoTracks();
            if (videoTracks.length === 0) { alert("有効なビデオトラックがありません。"); return; }
            const trackSettings = videoTracks[0].getSettings();
            photoCanvas.width = trackSettings.width || cameraPreview.videoWidth;
            photoCanvas.height = trackSettings.height || cameraPreview.videoHeight;

            const context = photoCanvas.getContext('2d');
            context.drawImage(cameraPreview, 0, 0, photoCanvas.width, photoCanvas.height);
            const dataUrl = photoCanvas.toDataURL('image/jpeg', 0.8);
            
            const photoTimestamp = Date.now();
            currentRecordingPhotos.push({ timestamp: photoTimestamp, dataUrl: dataUrl });
            
            lastPhotoPreviewContainer.innerHTML = `<img src="${dataUrl}" alt="撮影した写真" style="max-width:100px; max-height:100px; border:1px solid var(--md-sys-color-outline); border-radius:4px;"> <p style="font-size:0.7em; color: var(--md-sys-color-secondary);">${new Date(photoTimestamp).toLocaleTimeString()}に撮影</p>`;

            if (isRecording) currentSensorValues.photoTakenId = photoTimestamp;
            cameraStatusEl.textContent = `${new Date(photoTimestamp).toLocaleTimeString()} に写真を撮影しました。`;
        });


        // --- Geolocation, Reverse Geocoding & Weather Logic ---
        async function initializeGeolocation(forcePermissionRequest = false) {
            if (!('geolocation' in navigator)) {
                geoStatusEl.textContent = '位置情報 API 非対応'; geoStatusEl.classList.add('not-supported');
                geoAddressStatusEl.textContent = '位置情報 API 非対応';
                return Promise.resolve();
            }

            const handlePosition = (position) => {
                geolocationPermissionGranted = true; anySensorSupported = true;
                geoStatusEl.textContent = "監視中..."; geoStatusEl.classList.remove('error', 'not-supported');
                
                const { latitude, longitude, accuracy, altitude, speed, heading } = position.coords;
                currentSensorValues.latitude = latitude;
                currentSensorValues.longitude = longitude;
                currentSensorValues.gpsAccuracy = accuracy;
                currentSensorValues.altitude = altitude;
                currentSensorValues.speed = speed;
                currentSensorValues.heading = heading;

                geoLatEl.textContent = latitude !== null ? latitude.toFixed(5) : '-';
                geoLonEl.textContent = longitude !== null ? longitude.toFixed(5) : '-';
                geoAccEl.textContent = accuracy !== null ? accuracy.toFixed(1) : '-';
                geoAltEl.textContent = altitude !== null ? altitude.toFixed(1) : '-';
                geoSpeedEl.textContent = speed !== null ? speed.toFixed(1) : '-';
                geoHeadEl.textContent = heading !== null ? heading.toFixed(1) : '-';
                
                // Fetch reverse geocode and weather if new significant position
                const now = Date.now();
                const ScoordLatChanged = Math.abs(latitude - (lastFetchedAddressCoords.lat || 0)) > REVERSE_GEOCODE_MIN_COORD_CHANGE;
                const ScoordLonChanged = Math.abs(longitude - (lastFetchedAddressCoords.lon || 0)) > REVERSE_GEOCODE_MIN_COORD_CHANGE;

                if (latitude !== null && longitude !== null) {
                    if ((ScoordLatChanged || ScoordLonChanged || !currentSensorValues.address) && 
                        (now - lastReverseGeocodeFetchTime > REVERSE_GEOCODE_INTERVAL_MS)) {
                        fetchReverseGeocode(latitude, longitude);
                        lastFetchedAddressCoords = { lat: latitude, lon: longitude };
                        lastReverseGeocodeFetchTime = now;
                    }
                    fetchWeatherData(latitude, longitude); // Weather can be fetched more often if needed (throttled internally)
                }
                updateRecordingButtonState();
            };

            const handleError = (error) => {
                console.error('Geolocation error:', error);
                let message = 'GPSエラー';
                if (error.code === 1) message = 'GPSアクセス拒否';
                else if (error.code === 2) message = 'GPS位置取得不能';
                else if (error.code === 3) message = 'GPSタイムアウト';
                geoStatusEl.textContent = message; geoStatusEl.classList.add('error');
                geoAddressStatusEl.textContent = message;
                geolocationPermissionGranted = false;
                currentSensorValues.latitude = null; /* reset other geo values */
                currentSensorValues.longitude = null;
                currentSensorValues.address = null;
                geoAddressEl.textContent = "-";
                updateRecordingButtonState();
            };

            if (forcePermissionRequest || !geolocationPermissionGranted) {
                geoStatusEl.textContent = "GPSアクセス許可待機中...";
                geoAddressStatusEl.textContent = "GPSアクセス許可待機中...";
                return new Promise((resolve, reject) => {
                    navigator.geolocation.getCurrentPosition(
                        (position) => { 
                            handlePosition(position);
                            if (geoWatchId) navigator.geolocation.clearWatch(geoWatchId);
                            geoWatchId = navigator.geolocation.watchPosition(handlePosition, handleError, { enableHighAccuracy: true, timeout: 10000, maximumAge: 0 });
                            resolve();
                        },
                        (error) => { 
                            handleError(error);
                            reject(error); // Reject promise if initial permission fails
                        },
                        { enableHighAccuracy: true, timeout: 15000, maximumAge: 0 }
                    );
                });
            } else if (geolocationPermissionGranted && !geoWatchId) {
                 if (geoWatchId) navigator.geolocation.clearWatch(geoWatchId);
                 geoWatchId = navigator.geolocation.watchPosition(handlePosition, handleError, { enableHighAccuracy: true, timeout: 10000, maximumAge: 0 });
            }
            return Promise.resolve();
        }

        async function fetchReverseGeocode(latitude, longitude) {
            if (latitude === null || longitude === null) return;
            geoAddressStatusEl.textContent = "住所情報取得中...";
            try {
                const url = `https://nominatim.openstreetmap.org/reverse?format=jsonv2&lat=${latitude}&lon=${longitude}&accept-language=ja,en`;
                console.log("Requesting RevGeo:", url);
                const response = await fetch(url);
                if (!response.ok) {
                    throw new Error(`Nominatim API error: ${response.status} ${response.statusText}`);
                }
                const data = await response.json();
                console.log("RevGeo Data:", data);
                if (data && data.display_name) {
                    currentSensorValues.address = data.display_name;
                    geoAddressEl.textContent = data.display_name;
                    geoAddressStatusEl.textContent = `最終更新: ${new Date().toLocaleTimeString()}`;
                } else {
                    geoAddressEl.textContent = "取得失敗";
                    geoAddressStatusEl.textContent = "住所情報なし";
                    currentSensorValues.address = null;
                }
            } catch (error) {
                console.error("Failed to fetch reverse geocode data:", error);
                geoAddressEl.textContent = "取得エラー";
                geoAddressStatusEl.textContent = "住所情報取得エラー";
                currentSensorValues.address = null;
            }
        }

        async function fetchWeatherData(latitude, longitude) {
            const now = Date.now();
            if (now - lastWeatherFetchTime < WEATHER_FETCH_INTERVAL_MS && currentSensorValues.temperature_celsius !== null) {
                // Already have recent data, no need to spam
                return;
            }
            if (latitude === null || longitude === null || typeof latitude !== 'number' || typeof longitude !== 'number') {
                weatherStatusEl.textContent = "GPS座標不明";
                console.warn("[Weather] Invalid coordinates for weather fetch:", latitude, longitude);
                return;
            }
            
            weatherStatusEl.textContent = "天気情報取得中...";
            const apiUrl = `https://api.open-meteo.com/v1/forecast?latitude=${latitude.toFixed(4)}&longitude=${longitude.toFixed(4)}¤t_weather=true`;
            console.log("[Weather] Fetching weather from:", apiUrl);

            try {
                const response = await fetch(apiUrl);
                console.log("[Weather] Response status:", response.status, response.statusText);
                if (!response.ok) {
                    const errorText = await response.text();
                    console.error("[Weather] API error response text:", errorText);
                    throw new Error(`API error: ${response.status} ${response.statusText}`);
                }
                const data = await response.json();
                console.log("[Weather] Weather data received:", data);

                if (data && data.current_weather && typeof data.current_weather.temperature !== 'undefined') {
                    currentSensorValues.temperature_celsius = data.current_weather.temperature;
                    weatherTempEl.textContent = data.current_weather.temperature.toFixed(1);
                    weatherStatusEl.textContent = `最終更新: ${new Date().toLocaleTimeString()}`;
                    lastWeatherFetchTime = now;
                } else {
                    console.warn("[Weather] Temperature data not found in response:", data);
                    throw new Error("Temperature data not found in response.");
                }
            } catch (error) {
                console.error("[Weather] Failed to fetch weather data:", error);
                weatherStatusEl.textContent = "天気情報取得失敗";
                weatherTempEl.textContent = "-";
                // Do not clear currentSensorValues.temperature_celsius here, retain last known good value if any.
                // It will be overwritten on next successful fetch.
            }
        }


        // --- Recording Logic (startRecording updates, others same) ---
        function recordCurrentData() { /* ... (same as before) ... */ 
            if (!isRecording) return;
            const now = Date.now();
            let dataToRecord = { ...currentSensorValues, timestamp: now };
            currentRecordingData.push(dataToRecord);
            
            currentSensorValues.photoTakenId = null; 
            currentSensorValues.steps_interval = 0; 
            if (currentRecordingData.length % 10 === 0) { 
                recordingStatusEl.textContent = `記録中... (${currentRecordingData.length}件)`;
            }
        }

        function startRecording() { /* ... (updated for address reset) ... */ 
            if (!sensorsInitialized || (!anySensorSupported && !motionPermissionGranted && !orientationPermissionGranted && !micPermissionGranted && !geolocationPermissionGranted)) {
                alert("利用可能なセンサーがないか、センサーへのアクセスが許可されていません。");
                return;
            }
            isRecording = true;
            currentRecordingData = []; 
            currentRecordingPhotos = []; 
            lastPhotoPreviewContainer.innerHTML = ""; 

            currentSessionTotalSteps = 0;
            pedometerStepsEl.textContent = '0';
            pedometer_last_accel_mag = 0;
            pedometer_trending_up = false;
            pedometer_last_step_time = 0;

            // Weather and address are fetched/updated by their respective mechanisms if GPS is available
            // No need to explicitly reset currentSensorValues.address or temperature here, 
            // as they reflect the latest fetched values.
            lastWeatherFetchTime = 0; // Allow immediate weather fetch if GPS is good
            if (currentSensorValues.latitude !== null && currentSensorValues.longitude !== null) {
                fetchWeatherData(currentSensorValues.latitude, currentSensorValues.longitude);
                // Reverse geocode might also be triggered by handlePosition if conditions met
            } else {
                 weatherStatusEl.textContent = geolocationPermissionGranted ? "GPS位置情報取得後に更新" : "GPSアクセスが必要です";
                 geoAddressStatusEl.textContent = geolocationPermissionGranted ? "GPS位置情報取得後に更新" : "GPSアクセスが必要です";
            }

            if (recordingIntervalId) clearInterval(recordingIntervalId);
            recordingIntervalId = setInterval(recordCurrentData, RECORDING_INTERVAL_MS);
            updateRecordingButtonState();
            downloadCSVIconButton.disabled = true; 
        }

        function stopRecording() { /* ... (same as before) ... */ 
            isRecording = false;
            if (recordingIntervalId) {
                clearInterval(recordingIntervalId);
                recordingIntervalId = null;
            }
            
            if (currentRecordingData.length > 0) {
                const session = {
                    id: Date.now(),
                    startTime: currentRecordingData[0].timestamp,
                    endTime: currentRecordingData[currentRecordingData.length - 1].timestamp,
                    data: [...currentRecordingData],
                    photos: [...currentRecordingPhotos],
                    totalSteps: currentSessionTotalSteps 
                };
                allRecordedSessions.push(session);
                saveHistoryToLocalStorage();
                recordingStatusEl.textContent = `記録を停止しました。${currentRecordingData.length}件のデータを記録。履歴に追加されました。`;
            } else {
                recordingStatusEl.textContent = `記録を停止しました。データはありませんでした。`;
            }
            updateRecordingButtonState();
        }
        
        function downloadCSV(dataToExport, filenamePrefix = "sensor_data_current") { /* ... (same as before) ... */ 
            if (!dataToExport || dataToExport.length === 0) {
                alert("記録データがありません。");
                return;
            }
            // CSV Header now includes temperature and steps_in_interval. Address is not included in CSV.
            const header = "timestamp,accelX,accelY,accelZ,orientAlpha,orientBeta,orientGamma,gyroAlpha,gyroBeta,gyroGamma,illuminance,decibels,latitude,longitude,gpsAccuracy,altitude,speed,heading,temperature_celsius,steps_in_interval,photoTakenId";
            const rows = dataToExport.map(row => {
                return [
                    row.timestamp,
                    row.accelX !== null ? row.accelX.toFixed(3) : '',
                    row.accelY !== null ? row.accelY.toFixed(3) : '',
                    row.accelZ !== null ? row.accelZ.toFixed(3) : '',
                    row.orientAlpha !== null ? row.orientAlpha.toFixed(2) : '',
                    row.orientBeta !== null ? row.orientBeta.toFixed(2) : '',
                    row.orientGamma !== null ? row.orientGamma.toFixed(2) : '',
                    row.gyroAlpha !== null ? row.gyroAlpha.toFixed(3) : '',
                    row.gyroBeta !== null ? row.gyroBeta.toFixed(3) : '',
                    row.gyroGamma !== null ? row.gyroGamma.toFixed(3) : '',
                    row.illuminance !== null ? row.illuminance.toFixed(0) : '',
                    row.decibels !== null && isFinite(row.decibels) ? row.decibels.toFixed(1) : '',
                    row.latitude !== null ? row.latitude.toFixed(6) : '',
                    row.longitude !== null ? row.longitude.toFixed(6) : '',
                    row.gpsAccuracy !== null ? row.gpsAccuracy.toFixed(1) : '',
                    row.altitude !== null ? row.altitude.toFixed(1) : '',
                    row.speed !== null ? row.speed.toFixed(2) : '',
                    row.heading !== null ? row.heading.toFixed(1) : '',
                    row.temperature_celsius !== null ? row.temperature_celsius.toFixed(1) : '',
                    row.steps_interval !== null ? row.steps_interval : '0',
                    row.photoTakenId || ''
                ].join(',');
            });

            const csvContent = header + "\n" + rows.join("\n");
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement("a");
            const url = URL.createObjectURL(blob);
            const now = new Date(dataToExport[0].timestamp);
            const timestampStr = `${now.getFullYear()}${(now.getMonth()+1).toString().padStart(2,'0')}${now.getDate().toString().padStart(2,'0')}_${now.getHours().toString().padStart(2,'0')}${now.getMinutes().toString().padStart(2,'0')}${now.getSeconds().toString().padStart(2,'0')}`;
            link.setAttribute("href", url);
            link.setAttribute("download", `${filenamePrefix}_${timestampStr}.csv`);
            link.style.visibility = 'hidden';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
            if (filenamePrefix === "sensor_data_current") {
                recordingStatusEl.textContent = `CSVファイルをダウンロードしました。 (${dataToExport.length}件)`;
            }
        }
        if(startRecordingIconButton) startRecordingIconButton.addEventListener('click', startRecording);
        if(stopRecordingIconButton) stopRecordingIconButton.addEventListener('click', stopRecording);
        if(downloadCSVIconButton) downloadCSVIconButton.addEventListener('click', () => downloadCSV(currentRecordingData, "sensor_data_current"));

        // --- History Logic (same as before for save/load/delete, display updated) ---
        const HISTORY_STORAGE_KEY = 'sensorDemoProHistory_v2';

        function saveHistoryToLocalStorage() { /* ... (same as before) ... */ 
            try {
                localStorage.setItem(HISTORY_STORAGE_KEY, JSON.stringify(allRecordedSessions));
            } catch (e) {
                console.error("Error saving history to localStorage:", e);
                alert("履歴の保存に失敗しました。ストレージ容量が不足している可能性があります。");
            }
        }
        function loadHistoryFromLocalStorage() { /* ... (same as before) ... */ 
            const storedHistory = localStorage.getItem(HISTORY_STORAGE_KEY);
            if (storedHistory) {
                try {
                    allRecordedSessions = JSON.parse(storedHistory);
                    allRecordedSessions.forEach(session => {
                        if (typeof session.totalSteps === 'undefined') session.totalSteps = 0;
                    });
                } catch (e) {
                    console.error("Error parsing history from localStorage:", e);
                    allRecordedSessions = [];
                }
            } else {
                allRecordedSessions = [];
            }
        }

        function displayHistoryList() { /* ... (updated to show first recorded temperature if available) ... */ 
            historyListContainer.innerHTML = '';
            historyDetailView.style.display = 'none';
            historyListContainer.style.display = 'block';

            if (allRecordedSessions.length === 0) {
                noHistoryText.style.display = 'block'; return;
            }
            noHistoryText.style.display = 'none';
            allRecordedSessions.sort((a, b) => b.id - a.id);

            allRecordedSessions.forEach(session => {
                const sessionCard = document.createElement('md-elevated-card');
                sessionCard.style.marginBottom = '12px';
                const startTime = new Date(session.startTime);
                const durationMs = session.endTime - session.startTime;
                const durationSec = Math.floor(durationMs / 1000);
                const durationMin = Math.floor(durationSec / 60);
                const formattedStartTime = startTime.toLocaleString('ja-JP', { year: 'numeric', month: '2-digit', day: '2-digit', hour: '2-digit', minute: '2-digit' });

                let firstTemp = session.data.find(d => d.temperature_celsius !== null && typeof d.temperature_celsius === 'number');
                let tempString = firstTemp ? `${firstTemp.temperature_celsius.toFixed(1)}°C` : "記録なし";


                let content = `
                    <div style="padding: 16px;">
                        <div style="display: flex; justify-content: space-between; align-items: flex-start;">
                            <h4 style="margin-top:0; margin-bottom: 8px; font-size: 1.1em;">記録: ${formattedStartTime}</h4>
                            <md-icon-button class="delete-session-button" data-session-id="${session.id}" aria-label="この記録を削除">
                                <md-icon>delete</md-icon>
                            </md-icon-button>
                        </div>
                        <p style="font-size: 0.9em; margin: 4px 0;">
                            <md-icon style="font-size: 1.1em; vertical-align: bottom;">timer</md-icon>
                            記録時間: ${durationMin}分 ${durationSec % 60}秒
                        </p>
                        <p style="font-size: 0.9em; margin: 4px 0;">
                            <md-icon style="font-size: 1.1em; vertical-align: bottom;">list_alt</md-icon>
                            データ点数: ${session.data.length}件
                        </p>
                        <p style="font-size: 0.9em; margin: 4px 0;">
                            <md-icon style="font-size: 1.1em; vertical-align: bottom;">photo_library</md-icon>
                            写真枚数: ${session.photos ? session.photos.length : 0}枚
                        </p>
                        <p style="font-size: 0.9em; margin: 4px 0;">
                            <md-icon style="font-size: 1.1em; vertical-align: bottom;">directions_walk</md-icon>
                            推定歩数: ${session.totalSteps || 0} 歩
                        </p>
                         <p style="font-size: 0.9em; margin: 4px 0;">
                            <md-icon style="font-size: 1.1em; vertical-align: bottom;">thermostat</md-icon>
                            開始時気温 (目安): ${tempString}
                        </p>
                    </div>
                `;
                sessionCard.innerHTML = content;
                sessionCard.addEventListener('click', (event) => {
                    if (!event.target.closest('.delete-session-button')) displayHistoryDetail(session.id);
                });
                const deleteButton = sessionCard.querySelector('.delete-session-button');
                deleteButton.addEventListener('click', (event) => {
                    event.stopPropagation();
                    promptDeleteSession(session.id, formattedStartTime);
                });
                historyListContainer.appendChild(sessionCard);
            });
        }

        function promptDeleteSession(sessionId, sessionStartTimeFormatted) { /* ... (same as before) ... */ 
            sessionIdToDelete = sessionId;
            deleteDialogSessionInfo.textContent = `記録日時: ${sessionStartTimeFormatted}`;
            deleteConfirmDialog.show();
        }
        async function deleteSession(sessionId) { /* ... (same as before) ... */ 
            allRecordedSessions = allRecordedSessions.filter(session => session.id !== sessionId);
            saveHistoryToLocalStorage();
            displayHistoryList();
            if (historyDetailView.style.display === 'block' && !allRecordedSessions.some(s => s.id === sessionIdToDelete) ) {
                displayHistoryList();
            }
            sessionIdToDelete = null;
        }
        confirmDeleteButton.addEventListener('click', () => { /* ... (same as before) ... */ 
            if (sessionIdToDelete !== null) deleteSession(sessionIdToDelete);
            if (deleteConfirmDialog.close) deleteConfirmDialog.close('delete');
        });
        deleteConfirmDialog.addEventListener('closed', (event) => { /* ... (same as before) ... */ 
            if(event.detail.action !== 'delete' && event.detail.action !== 'cancel') { // md-dialog might return other values
                sessionIdToDelete = null;
            } else if (event.detail.action === 'cancel'){
                 sessionIdToDelete = null;
            }
        });

        function displayHistoryDetail(sessionId) { /* ... (same chart logic as before) ... */ 
            const session = allRecordedSessions.find(s => s.id === sessionId);
            if (!session) { displayHistoryList(); return; }

            historyListContainer.style.display = 'none';
            historyDetailView.style.display = 'block';
            const startTime = new Date(session.startTime);
            const formattedStartTime = startTime.toLocaleString('ja-JP', { year: 'numeric', month: '2-digit', day: '2-digit', hour: '2-digit', minute: '2-digit' });
            historyDetailTitle.textContent = `記録詳細: ${formattedStartTime} (歩数: ${session.totalSteps || 0}歩)`;
            
            historyPhotosContainer.innerHTML = '';
            if (session.photos && session.photos.length > 0) {
                session.photos.forEach(photo => {
                    const img = document.createElement('img');
                    img.src = photo.dataUrl;
                    img.alt = `Photo from ${new Date(photo.timestamp).toLocaleTimeString()}`;
                    img.style.maxWidth = '100px'; img.style.maxHeight = '100px';
                    img.style.borderRadius = '4px'; img.style.border = '1px solid var(--md-sys-color-outline)';
                    historyPhotosContainer.appendChild(img);
                });
            } else {
                historyPhotosContainer.innerHTML = '<p>この記録中に撮影された写真はありません。</p>';
            }

            exportHistoryCSVButton.onclick = () => downloadCSV(session.data, `sensor_data_history_${session.id}`);
            
            if (historyChartInstance) historyChartInstance.destroy();
            const ctx = historyChartCanvas.getContext('2d');
            const labels = session.data.map(d => new Date(d.timestamp).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', second: '2-digit', fractionalSecondDigits: 1 }));
            
            const datasets = [];
            if (session.data.some(d => d.accelX !== null)) datasets.push({ label: 'Accel X', data: session.data.map(d => d.accelX), borderColor: 'red', fill: false, tension: 0.1, hidden: true });
            if (session.data.some(d => d.accelY !== null)) datasets.push({ label: 'Accel Y', data: session.data.map(d => d.accelY), borderColor: 'green', fill: false, tension: 0.1, hidden: true });
            if (session.data.some(d => d.accelZ !== null)) datasets.push({ label: 'Accel Z', data: session.data.map(d => d.accelZ), borderColor: 'blue', fill: false, tension: 0.1 }); 
            if (session.data.some(d => d.gyroAlpha !== null)) datasets.push({ label: 'Gyro Alpha', data: session.data.map(d => d.gyroAlpha), borderColor: 'purple', fill: false, tension: 0.1, hidden: true });
            if (session.data.some(d => d.orientBeta !== null)) datasets.push({ label: 'Orient Beta (X)', data: session.data.map(d => d.orientBeta), borderColor: 'orange', fill: false, tension: 0.1, hidden: true });
            if (session.data.some(d => d.illuminance !== null)) datasets.push({ label: 'Illuminance (lux)', data: session.data.map(d => d.illuminance), borderColor: 'teal', fill: false, tension: 0.1, yAxisID: 'yLux', hidden: true });
            if (session.data.some(d => d.decibels !== null && isFinite(d.decibels))) datasets.push({ label: 'Decibels (dBFS)', data: session.data.map(d => isFinite(d.decibels) ? d.decibels : null), borderColor: 'magenta', fill: false, tension: 0.1, yAxisID: 'yDb', hidden: false });
            if (session.data.some(d => d.altitude !== null)) datasets.push({ label: 'Altitude (m)', data: session.data.map(d => d.altitude), borderColor: 'brown', fill: false, tension: 0.1, yAxisID: 'yAlt', hidden: false });
            if (session.data.some(d => d.temperature_celsius !== null)) datasets.push({ label: 'Temperature (°C)', data: session.data.map(d => d.temperature_celsius), borderColor: 'coral', fill: false, tension: 0.1, yAxisID: 'yTemp', hidden: false });

            historyChartInstance = new Chart(ctx, {
                type: 'line',
                data: { labels: labels, datasets: datasets },
                options: {
                    responsive: true, maintainAspectRatio: false,
                    scales: {
                        x: { title: { display: true, text: 'Time' } },
                        y: { title: { display: true, text: 'Sensor Values (m/s², °/s, °)' } },
                        yLux: { type: 'linear', display: true, position: 'right', title: {display: true, text: 'Lux'}, grid: { drawOnChartArea: false, } },
                        yDb: { type: 'linear', display: true, position: 'right', title: {display: true, text: 'dBFS'}, grid: { drawOnChartArea: false, } },
                        yAlt: { type: 'linear', display: true, position: 'right', title: {display: true, text: 'Altitude (m)'}, grid: { drawOnChartArea: false, } },
                        yTemp: { type: 'linear', display: true, position: 'right', title: {display: true, text: 'Temp (°C)'}, grid: { drawOnChartArea: false, } }
                    },
                    plugins: { legend: { position: 'top' } }
                }
            });
        }
        
        backToHistoryListButton.addEventListener('click', displayHistoryList);
        function loadAndDisplayHistory() {
            loadHistoryFromLocalStorage();
            displayHistoryList();
        }

        // --- Initial Setup ---
        loadHistoryFromLocalStorage(); 
        updateRecordingButtonState(); 
        showPage('recordPage');

    </script>
</body>
</html>